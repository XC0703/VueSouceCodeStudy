## 17-1 学习本项目的好处

虽然本项目是 vue3 的最简化模型，但是”麻雀虽小，肝胆俱全“，功能基本完善，代码量也足够，跟着做完也会受益颇丰：

- **进一步学习了解 vue 的核心原理和逻辑：比如订阅发布响应式系统的实现，diff 算法的具体逻辑，组件渲染的过程，模版编译的流程等**；
- **了解到工业级代码库优秀的设计：比如 monorepo 的代码组织架构 ，shapeFlag、patchFlag 的设计方式，策略模式、工厂模式等设计模式在源码中的运用**；
- **掌握”测试驱动开发“的思想，提高自己的代码编写及调试能力**；
- **了解 monorepo、rollup 的配置，拓宽技术栈**；
- **提高自己文档撰写和总结的能力**。

## 17-2 文档阅读的重点

- monrepo 环境的搭建：[1、Vue3 环境的搭建.md](./1%E3%80%81Vue3%20%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA.md)。
- 响应式的订阅发布实现：[3、依赖收集.md](./3%E3%80%81%E4%BE%9D%E8%B5%96%E6%94%B6%E9%9B%86.md)、[4、触发更新.md](./4%E3%80%81%E8%A7%A6%E5%8F%91%E6%9B%B4%E6%96%B0.md)
- 渲染的流程：[9、组件的渲染（一）](./9%E3%80%81%E7%BB%84%E4%BB%B6%E7%9A%84%E6%B8%B2%E6%9F%93%EF%BC%88%E4%B8%80%EF%BC%89.md)
- diff 算法：[12、组件的更新（二）.md](./12%E3%80%81%E7%BB%84%E4%BB%B6%E7%9A%84%E6%9B%B4%E6%96%B0%EF%BC%88%E4%BA%8C%EF%BC%89.md)
- 模版编译的流程：[14、模版的处理（一）.md](./14、模版的处理（一）.md)

## 17-3 一些面试题

### 17-3-1 vue 双向数据绑定的原理？

单向比较好理解，比如一个变量在元素中呈现，这是一个方向，视图的元素绑定了某个函数可以改变该变量，这是另一个方向，如果此时变量改变后元素呈现的值也相应变了，此时便是双向了。`vue` 的双向数据绑定指的是视图和响应式数据之间的双向，主要基于 `Observer`、`Watcher`、`Compile` 三者实现。

`Observer` 负责数据劫持，主要基于 `Proxy` 实现，具体为 `vue` 初始化时，那些响应式数据都会被处理成一个 `proxy` 对象，当整个对象或者对象某一个属性被使用时触发 getter 方法，然后去收集 `effect` 依赖（`effect` 本质是响应式数据被改变时要去触发的函数，即视图的更新相关，即上面提到的 `Watcher`），即一个对象会有很多个属性，每个属性都有自己的 `effect` 依赖列表并接受各自的依赖管理器管理便于获取正确的 `effect`，最终实现嵌套的 `map` 结构。在模板进行初始化编译时，会找到其中动态绑定的数据，从 `data` 中获取并初始化视图，同时元素上会绑定相应的响应式数据更新函数，这个过程发生在 `Compile` 中。

此时便实现了上面提到的双向数据绑定的效果，当元素上绑定的数据更新函数触发时，会触发响应式数据的 `proxy` 对象的 `setter` 方法，并通过该对象的依赖管理器找到正确的 `effect` 函数去触发，从而去实现视图的更新。

### 17-3-2 diff 算法的总结？

1. 首先 vue 组件的渲染借助了虚拟 dom 的原理，组件更新时，因为响应式的存在，会去重新生成一个 vnode。
2. 此时，进入新老两个 vnode 比较阶段，首先会对比是否是相同元素，如果不是相同元素，则之间卸载老的节点，重新走 mountElement 方法去挂载渲染节点。
3. 如果是相同元素，则会去对比 props 参数， props 不同有三种情况（依据实际情况进行对属性进行处理即可）：
   - 属性在新旧中都有，但是值不一样
   - 在旧的组件中有，在新的中没有
   - 在新的组件中有，在旧的中没有
4. props 对比介绍之后，便会去对比 children 子节点，这也是 diff 算法中最复杂最核心的内容。children 子节点本质上是一个可以嵌套的数组，对于嵌套子节点的处理，直接走递归即可。对于同一层级下的新旧对比，又分为简单情况和复杂情况的处理。
   - 简单情况是利用了双端 diff 算法，本质是利用双指针的原理，处理新旧子节点都是数组且头部或者尾部节点可复用的情况，其中新的子节点数量的时候要插入，旧的子节点数量多的时候要删除。处理这种简单情况时，我们只考虑了顺序的情况，要么都要新增，要么都要删除。
   - 但实际有些节点是可以复用的只是顺序变了，有些要新增，有些则要删除。对于这种复杂情况的处理，vue 引入了映射表，即以新的乱序节点为基准创建一个映射表；再遍历旧的乱序节点过程中去该映射表查找是否已存在，如果有，说明是可以复用的，如果没有，说明是该旧节点需要删除的。
   - 此时再用一个数组 newIndexToOldIndexMap 来表示新的节点在旧的节点数组中的索引+1，默认为 0 表示该节点不存在旧的节点序列中。
   - 之后倒序遍历该数组，如果值为 0 表示要新增该节点，如果不为 0 则要移动节点到正确的位置。移动时默认是一个个移动的，产生了一些没有必要的性能损耗，比如某个区段的子节点顺序都没有变，可以不用操作这部分节点。
   - 因此 vue 中引入了最长递增子序列的原理，在移动某个节点前，判断该节点是否在最长递增子序列中，在则不用移动跳过即可，继续操作前一个节点。
5. Vue 3 的算法效率更高，因为它使用了一些优化技巧，例如按需更新、静态标记等，会跳过静态子树的比较减少比较次数。

### 17-3-3 谈一下 vue3 的 diff 算法发生了哪些变更？

随着 Vue 3.0 的发布，其 diff 算法相较于 Vue 2.x 版本有了很多变化，这里简单概括一下其中的主要变更：
**1、patchFlag**
在 Vue 3.0 中，通过 patchFlag 标记 VNode 的类型和操作（比如属性或子元素），以便后续更新时可以跳过一些无需更新的节点，从而显著提升更新效率。
**2、静态提升**
Vue 3.0 支持将静态节点在编译时优化，从而避免在后续更新时对它们进行比较，进一步提升更新效率。
**3、缓存事件处理函数**
Vue 3.0 缓存事件处理函数，避免在每次更新时都重新创建相同的函数对象，从而减少性能损耗。
**4、HoistStatic**
Vue 3.0 中引入了 HoistStatic 优化，即将静态节点和静态子树抽离出来，以便更好地利用浏览器的 DOM 节点复用机制。
**5、Block tree**
Vue 3.0 使用基于 Block tree 的优化策略，即将组件树抽象为若干个 Block，在每个 Block 内部进行 VNode 的比较和更新，进一步减小了更新的消耗。

### 17-3-4 vue3 性能优化？

vue3 主要从以下三个方面对性能作出了优化：

- **体积优化** ：Vue 3.0 采用了 Tree-shaking 技术，使得打包后的包更小，同时也使得 Vue 3.0 在移动端的表现更好。任何一个函数，如 ref、reavtived、computed 等，仅仅在用到的时候才打包，没用到的模块都被摇掉，打包的整体体积变小。
- **编译优化**：Vue3 在模板编译阶段阶段时，会进行静态节点标记优化，即调用调用 optimize 方法遍历 template 字符串转化而成的抽象语法树 AST，方便在页面重渲染的时候进行 diff 比较时，直接跳过这一些静态节点，优化 runtime 的性能。
- **数据劫持优化**：vue2 中采用 defineProperty 来劫持整个对象，然后进行深度遍历所有属性，给每个属性添加 getter 和 setter，实现响应式 vue3 采用 proxy 重写了响应式系统，因为 proxy 可以对整个对象进行监听，所以不需要深度遍历，进而提高了性能。

### 17-3-5 vue 编译到渲染的原理？

1. **模板编译阶段**：将模板编译成渲染函数(`render function`)。在这个阶段，`Vue` 会将类似于`{{msg}}`这样的指令和语法解析成对应的 `JavaScript` 代码，生成一个渲染函数（`render function`）。模板编译又分三个阶段，解析 `parse`、加工优化 `transform`、生成 `generate`，最终生成可执行函数 `render`。

   - **解析阶段**：调用 ` parse`` 方法对 template ` 字符串进行解析（原理是基于正则表达式），将标签、指令、属性等转化为抽象语法树 `AST`。
   - **加工优化阶段**：调用 `transform` 方法遍历 `AST`，找到其中的一些静态节点并进行标记，方便在页面重渲染的时候进行 `diff` 比较时，直接跳过这一些静态节点，优化 `runtime` 的性能。
   - **生成阶段**：调用 `generate` 方法将最终的 `AST` 转化为 `rende`r 函数字符串 `render` 字符串并将静态部分放到 `staticRenderFns` 中，最后通过 `new Function(` render``) 生成 `render` 函数。

2. **渲染阶段**：创建虚拟 `DOM` 树，并根据渲染函数生成 `VNode` 节点树。在这个阶段，Vue 根据模板中的指令和数据生成一个虚拟 `DOM` 树，然后将虚拟 `DOM` 树转换成 `VNode` 节点树。
3. **更新阶段**：将新的 `VNode` 节点树渲染到真实的 `DOM` 上。在这个阶段，`Vue` 会通过比较新旧 `VNode` 树来确定哪些节点需要被更新、哪些节点需要被新增或删除，并且将更新后的 `VNode` 节点树渲染到真实的 `DOM` 上。
